\chapter{In-depth component description}

\section{Communicating with Channels}

\texttt{Channel} is an interface for performing I/O operations. It represents the principal abstraction used to communicate with the external world.

In this new middleware architecture, \texttt{Channel}s are designed to implement a complete communication stack. This characteristics makes them better suited

\texttt{Channel}s are open upon creation, and may be optionally closed by invoking the \texttt{close()} method to relinquish resources. Once closed, a \texttt{Channel} cannot be reopened again, and every subsequent attempt to perform an IO operation will fail causing a \texttt{ChannelException} to be thrown. The status of a \texttt{Channel} can be probed through its \texttt{isClosed()} method.

As can be seen in \ref{lst:channel}, \texttt{Channel}s are identified by an string identifier, used 


\lstset{language=Java}
\begin{lstlisting}[caption=The Channel interface,label={lst:channel}]
public interface Channel {
	public String getId();
	
	public IOTask submit(IORequest request, IOHandler handler)
			throws ChannelException;
	
	public void setAsyncIOHandler(IOHandler handler)
			throws IllegalStateException;
			
	public boolean isClosed();
	
	public void close();		
}
\end{lstlisting}

There is no limit on the number of channels used by an FPC. Complex behaviours can be implemented using different channels

What is a Channel? What does it do?

Interface description: methods, IORequest, IOHandler IOTask and Payload.
ByteArrayPayload description

The new Channel structure is monolithic, in that it contains all network layers required for the communication. This is in contrast with the previous middleware architecture, where communication layers where diveded between the legacy Channel implementation and the FPC. This new structure allows better reuse of off-the-shelf libraries.

ChannelFactory interface, methods and generic ChannelDescriptor structure

Basic XML 

\subsection{IORequest management}

Customizing request with parameters

IORequestBuilder and IORequestBuilderFactory

\subsection{Handling asynchronous data transmissions}

setAsyncIOHandler, how does it work and why do we need it

\subsection{Implementations: HTTPChannel and SimulatorChannel}

Full examples of actual implementations, complete with XML descriptor snippets


\section{Encoding and decoding information}

\subsection{The Message and Mapper interfaces}

\subsection{Handling composite data structures}

\subsection{Managing multiple message types}

\subsection{Implementations: JSONMapper and URLEncodedMapper}


\section{Data management: Scripts}

\subsection{From Messages to Records}

\subsection{Available instructions}

\subsection{Engine architecture and execution model}

\subsection{Script examples}


\section{Putting it all together: the FPC}

\subsection{Data access interface}

\subsection{Controlling the remote device}

\subsection{Scheduling mechanism}


\section{Device Descriptor and FPC Factory}

\subsection{The XML Device Descriptor}

\subsection{FPC Factory}

\subsection{Registry}

\subsection{Complete XML Device Descriptor examples}
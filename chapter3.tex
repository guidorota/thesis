\chapter{New middleware architecture}

\section{Design goals and core concepts}

\section{Architecture overview}

The PerLa Middleware is responsible for managing the lifecycle of all devices
connected to the PerLa framework, and for providing a uniform API to interact
with them. Its design revolves around the Functionality Proxy Component
(\texttt{FPC}), a self-contained proxy object that embeds all the logic
required to communicate with a single remote device.  The most prominent trait
of the \texttt{FPC} is its interface, an API that allows PerLa users to
interact with the sensing network through two hardware-agnostic communication
primitives, named get() and set().  Use of this interface neither requires
knowledge of the sensing network, nor of the device that will ultimately
perform the requested operation.

\begin{figure}[h!]
\center
\includegraphics[width=0.6\textwidth]{imgs/fpc.pdf}
\caption{Internal FPC structure}
\label{fig:fpc_overview}
\end{figure}

Each \texttt{FPC} is formed from the composition of various independent
software units, each of which is responsible for the management of a single
aspect of the interaction with the remote device (see
figure~\ref{fig:fpc_overview}). This modular design was chosen to promote
reusability and foster future expandability through composition of
independent objects. The following list contains a synopsis of the modules
that form an \texttt{FPC}:

\begin{itemize}

    \item \textbf{Channel:} A software component capable of performing I/O
    operations. \texttt{Channels} are responsible for managing the
    communication between the PerLa framework and the remote devices;

    \item \textbf{Mapper:} A data marshaller/unmarshaller. \texttt{Mappers}
    allow the \texttt{FPC} to interpret byte streams received from a Channel,
    and to serialize high-level data structures prior to transmission;

    \item \textbf{Script Engine:} An interpreter for executing PerLa
    \texttt{Scripts}, small programs written in a proprietary PerLa scripting
    language, which are used to dynamically bind high level data requests to
    native processing tasks performed on the remote device;

    \item \textbf{Operation Scheduler:} Schedules the execution of concurrent
    data collection operations on the remote device. The scheduler may simulate
    certain operations if the device connected to the FPC is not able to
    perform them natively (e.g., periodic sampling may be simulated by polling
    the remote device at regular intervals).

\end{itemize}

\begin{figure}[h!]
\includegraphics[width=\textwidth]{imgs/middleware_overview.pdf}
\caption{Internal FPC structure}
\label{fig:fpc_overview}
\end{figure}

New \texttt{FPC} objects are instantiated at runtime by the
\texttt{FPCFactory}. The starting point for the creation of an \texttt{FPC} is
the Device Descriptor, an XML document which contains a machine parseable
description of a single sensing device. Device Descriptors are organised in
different sections, each of which defines the configuration of one of the
aforementioned \texttt{FPC} modules. The \texttt{FPCFactory} can receive new
Device Descriptors directly from the node being connected (Plug\&Play
behaviour), or from another entity that acts on behalf of it (off-band
behaviour). The latter approach allows devices which are not capable of
autonomously transmit their Device Descriptor to be registered on the PerLa
Middleware.

A reference to each \texttt{FPC} is stored in the \texttt{Registry}, a
Middleware component that is responsible for maintaining a complete index of
all devices accessible through the PerLa framework. Thanks to the
\texttt{Registry}, PerLa user can discover sensing nodes through
capability-based queries, and retrieve the \texttt{FPC} objects that can be
used to interact with them.

\subsection{Asynchronous interaction paradigm}
\label{sec:newmiddleware.async}

One of the major differences between the New and Classic Middleware
architectures lies in the paradigm employed to interconnect internal modules of
the PerLa software infrastructure. The New Middleware design introduces a fully
asynchronous interaction paradigm that deviates profoundly from the mechanism
previously promoted, as it is based on non-blocking method invocations and
event-driven programming techniques.

\begin{figure}[h!]
    \center
    \includegraphics[width=0.5\textwidth]{imgs/pipe_waiter.pdf}
    \caption{A typical \texttt{Pipe}-\texttt{Waiter} connection in the Classic
        PerLa Middleware}
\end{figure}

Within the previous Middleware architecture, a connection between two different
modules was achieved by means of a decoupling element dubbed \texttt{Pipe}, a
one-way message queue designed to shuttle data elements from a software
component to its intended receiver. This system proved to be crucial in the
first development stages of PerLa, as its generic interface allowed the early
designers to experiment with several competing architectures and component
combinations. However, its flexibility came at a cost, both in terms of
performances and API readability. First of all, each \texttt{Pipe} allocated an
initial memory cache of 10 elements. Moreover, the receiving end of a
\texttt{Pipe}, namely the \texttt{Waiter}, was required to instantiate a Java
thread dedicated solely to the reception of data messages. The widespread use
of the \texttt{Pipe}-\texttt{Waiter} paradigm thus led to the proliferation of
threads and to an overuse of memory, which negatively impacted the overall
system efficiency. In addition, the loosely coupled interaction paradigm
promoted by the Classic Middleware resulted in a weak API that lacked intent
and semantic clarity.

The asynchronous, event-driven architecture implemented in the New Middleware
is designed to overcome all aforementioned drawbacks, and to improve the
overall system throughput and scalability. Differently from the deprecated
\texttt{Pipe}-driven architecture, this design fosters a direct exchange of
information between data producers and data consumers; information is no more
delivered using a mandatory middleman (i.e., the \texttt{Pipe}), but is
explicitly handed over to the intended recipients. This interaction paradigm is
based on the \textit{Hollywood Principle} (don't call us, we call you), a
software design methodology that encourages the development of highly-cohesive,
low-coupling APIs.

\begin{figure}[h!]
\center
\includegraphics[width=0.8\textwidth]{imgs/async_paradigm.pdf}
\caption{Sequence diagram of an asynchronous method call. Note that the
consumer and the producer continue their execution in parallel.}
\label{fig:async_paradigm}
\end{figure}

An asynchronous method call in the New PerLa Middleware is identified by the
following characteristics:

\begin{itemize}

    \item \textbf{Does not block:} Calls to an asynchronous method never block;
        control of the execution flow is immediately returned to the caller,
        and the requested computation is executed asynchronously. This
        characteristics reduces the number of Java threads that the caller
        module needs to instantiate;

    \item \textbf{Returns a Task object:} Asynchronous method calls do not
        return the immediate result of a computation. Instead, they return a
        \texttt{Task}, an object that can be employed to stop the ongoing
        operation or to query its current state of progress;

    \item \textbf{Deferred delivery of results:} The effective Result is
        notified by invoking a \texttt{Handler} function passed by the caller
        itself.

\end{itemize}

\subsection{Factory Plugin System}
\label{sec:newmiddleware.factory}

The New Middleware expands upon the concept of Factory by
introducing a modular Plugin System that improves the flexibility and
expandability of PerLa. The Factory is a widespread design pattern that allows
the creation of new objects without specifying at compile time which exact
class will be instantiated. This object creation abstraction is equivalent to a
polymorphic constructor that uses runtime information to create new class
instances.

The new \texttt{FPCFactory} is a modular software entity composed of many
sub-factories, each of which is dedicated to the creation of a specific
\texttt{FPC} component.

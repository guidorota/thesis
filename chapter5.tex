\chapter{Conclusions}
\label{cha:conclusions}

This thesis described the design and implementation of an asynchronous data
access middleware for Pervasive Systems. As shown in previous chapters, this
process began with an analysis aimed at identifying the weaknesses and
strengths of the Classic PerLa Middleware architecture, which was later used to
outline a basic set of goals to be followed during the development of the
software hereby described. From these goals ensued a New Middleware design
(chapter~\ref{cha:middleware_overview}), and a concrete implementation
(chapter~\ref{cha:components}). The most important contributions that the
development of this new data access middleware brought to the PerLa System can
be classified into three categories: modularization of the Plug \& Play device
registration process, asynchronous data flow management, and an improved
\texttt{FPC}. 

The new Plug \& Play device registration process was enhanced with three
distinct measures: first, the internal structure of the \texttt{FPC} component
was split into independent modules; second, the \texttt{FPCFactory} itself was
modularized into several sub-factory units, one for each \texttt{FPC}
component; third, a Plugin System was designed to allow the addition of new
\texttt{FPC} components without requiring any direct modification to the
\texttt{FPCFactory} itself. This new architecture was then validated by the
implementation of five different modules, three created by the author of this
thesis (\texttt{JSONMapper}, \texttt{URLEncodedMapper} and
\texttt{SimulatorChannel}), and two by other graduate student
(\texttt{HTTPChannel} and \texttt{TinyOSChannel}).

Another crucial aspect of the New PerLa Middleware design is represented by the
asynchronous data flow management paradigm. As explained in
section~\ref{sec:newmiddleware.async}, all components of the new architecture
implement an asynchronous event-driven API that improves both memory usage and
global reaction times of the overall system. An example of the benefits brought
by this new paradigm can be derived by analysing the number of threads
instantiated for each \texttt{FPC} registered in the system. In the Classic
Middleware, each \texttt{FPC} was composed of four distinct Java threads (one
for reading incoming messages, one for the \texttt{Unmarshaller}, one for the
    \texttt{Marshaller} and one the creation of output records). Conversely,
    within the New Middleware infrastructure, a single Java thread located in
    the \texttt{Channel} module is enough to drive all data handoffs from
    remote device to user. Additional threads may be instantiated during the
    execution of PerLa \texttt{Script}s; however, it is worth noting that these
    are managed by the \texttt{Script Engine}, and are always shared among all
    running \texttt{FPC}s (see chapter~\ref{cha:components} for additional
    details).

The \texttt{FPC} benefits from another improvement brought by the New
Middleware design, namely the PerLa Scripting Language. This new feature allows
for an advanced mapping between device capabilities and data
    \texttt{Attributes} exposed by the \texttt{FPC} component.


\section{Future work}

\subsection{Implementation of new plugins}

The New PerLa Middleware is designed to be expanded through the addition of new
modules, and it should come as no surprise that one of its intended evolution
paths consists in fact in the development of new Plugins. As described in
chapter~\ref{cha:components}, there are two main types of modules that can be
added to the PerLa Plugin System: \texttt{Channels} and \texttt{Mappers}.

The possibility to add new \texttt{Channel} implementations is a distinguishing
feature of the New Middleware design that should be effectively exploited to
extend the range of supported endpoint devices. At the time of writing the
selection of Plugins shipped with the core Middleware distribution allows PerLa
to connect with HTTP services and TinyOS motes. This initial line-up should be
only considered as a starting point, since a larger assortment of communication
systems is required to manage even the most rudimentary Pervasive Systems. The
following list contains a choice of protocols and networking technologies for
which a dedicated \texttt{Channel} implementation is advised:

\begin{itemize}

    \item \textbf{TCP/IP:} Widely employed in a vast variety of devices,
    ranging from high-end personal computers to low power devices;

    \item \textbf{Bluetooth LE:} One of the leading technologies for wireless
    area networks. Currently supported by all major Operating Systems,
    Bluetooth LE found its way into many different applications, like fitness
    bands, smartphones, healthcare instruments, home entertainment devices and
    localization beacons;

    \item \textbf{IEEE 802.15.4 based protocols:} IEEE 802.15.4 is a physical
    layer widely employed in many personal area network protocols. It is the
    basis for many networking specifications like Zigbee, Xbee and MiWi;

    \item \textbf{RS232:} Serial port communication. Its implementation should
    be considered in order to connect with legay devices and other low power
    systems (e.g., Arduino).

\end{itemize}

\texttt{Mapper}s represent another extension point of the PerLa Middleware
infrastructure that can be used to support additional data formats and
encodings. The only \texttt{Mapper} components available as of December 2014
in the core Middleware distribution provide support for JSON and URL-encoded
data structures. Analogously to what arelady stated for the \texttt{Channel}
component, future PerLa developers should consider implementing new
\texttt{Mapper}s to support the following data formats:

\begin{itemize}

    \item \textbf{C/C++ structs:} Its implementation should be a simple
    backport from the Classic Middleware architecture;

    \item \textbf{XML:} A markup language for document encoding;

    \item \textbf{CSV (Comma-Separated Values):} A simple format for the
    transmission and storage of tabular data.

\end{itemize}

\subsection{Alternative Device Descriptor forms}

As introduced in chapter~\ref{cha:components}, the new Plug \& Play node
registration system is comprised of two separate elements: a
\texttt{DeviceDescriptorParser} front-end, which analyzes the Device Descriptor
to build a format-agnostic Java representation of the Device Descriptor itself,
and the \texttt{FPCFactory}, which consumes this intermediate Java
representation to assemble the final \texttt{FPC}. This new architecture was
conceived to facilitate the future addition of alternative Device Descriptor
formats, which can now be easily performed by simply developing an appropriate
\texttt{DeviceDescriptorParser} module.

There are two main reasons for adding a new Device Descriptor representation:
first, to support a different data format that may be more convenient for some
devices (e.g., a JSON Device Descriptor); second, to create \texttt{FPC}s using
readily available industry standard device description technologies. This
former motivation leads us to one future development of the PerLa
infrastructure, namely the possibility of introducin a
\texttt{DeviceDescriptorParser} for the \textit{SensorML} \cite{sensorml}
sensor description format. Through this effort the PerLa Middleware would be
immediately compatible all devices for which a SensorML description is already
available.

\subsection{Distributed PerLa}
